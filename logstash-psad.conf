input {
	file {
		type => "psad"
		#Read in psad status.out. This file is regenerated by psad -S
		#for snapshot statistics set psad -S to a cron job
		#or for live statistics filter iptables.log.
		path => "/var/log/psad/status.out"
		start_position => "beginning"
		sincedb_path => "/opt/logstash/sincedb-psad"
		}
}



filter{
	if [type] == "psad" {
		#Drop Header rows and empty rows
		if [message] =~"[+]"
		{
			drop{}
		}
		if [message] ==""
		{
			drop{}
		}

	#Combine multiline data from psad log
	multiline{
		pattern => "^\s"
		negate => false
		what => previous
	}

	#identify source (attacker) IP address
	grok {
		match => [
		"message", "SRC:  %{IPV4:SRC_IP}"
		]
	}	

	#identify DST IP address
	grok {
		match => [
		"message", "DST: %{IPV4:DST_IP}"
		]
	}

	#identify scanned ports, number of packets, chain type, and interface
	grok {
		match => [
		"message", "Scanned ports: %{DATA:PORTTYPE} %{DATA:PORT}, Pkts: %{DATA:NUM_OF_PACKETS}, Chain: %{DATA:CHAIN_TYPE}, Intf: %{DATA:INTERFACE}\n"
		]
	}

	#gather vulnerability attempt. This is the most interesting when charted in kibana
	grok {
		match=> [
		"message", "Signature match: \"%{DATA:VULN_ATTEMPT}\""
		]
	}

	}
}

#Send to elasticsearch host
output {

	#uncomment stdout for testing
	#stdout {}

	elasticsearch { host => "10.10.10.10" }

}